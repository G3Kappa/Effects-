# Copies a variable into the program counter
Def VMJump(Name, Addr)
    WORDCpy(Addr, Name*PC) 
End

# Sets the program counter to a constant value
Def VMJumpConst(Name, Addr)
    WORD(Name*PC, Addr) 
End



# Sleeps for a given amount of ticks, then increases the program counter.
# TODO: Use DWORD once there's constants that go up to 256. 
Def VMSleepImpl(Name, Method, Then)
Chain {
    Filter DWORDEqConst(Name_Sleep, 0, 0) Chain {
        Method
    }
    DWORDDec(Name_Sleep)
    FirstSuccessful {
        Filter Not DWORDEqConst(Name_Sleep, 0, 0) Chain {
            WORDDec(Name*PC)
        }
        Chain { Then }
    }
}
End

Def VMSleepConst(Name, Ticks1, Ticks2, Then)
    VMSleepImpl(Name, DWORD(Name_Sleep, Ticks1, Ticks2), Then)
End

Def VMSleep(Name, Ticks, Then)
    VMSleepImpl(Name, DWORDCpy(Ticks, Name_Sleep), Then)
End

Def VMInit(Name)
    # Initializes the program counter and program array by zeroing them out
    VMJumpConst(Name, 0)
    ARRAY(Name.Code)
End

Def VMDestroy()
    DestroyWalls BASH
End

Def MakeGeneralPurposeVirtualMachine(
    Name, 
    ViewId, 
    OnCreated, 
    OnTick, 
    OnHalt, 
    OnDestroyed, 
    Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, Op9, OpA, OpB, OpC, OpD, OpE, OpF
)
# Creates a lock for this VM so that only one instance may execute at a given time
MakeLock(LOCK_VM_Name, CEILING, TORCH1, Rgb 0 0 0 0)
# Creates the actual VM furniture
"EFFECTS#Name"
{
    name = "Name"
    viewId = ViewId
    tickType = Effect Chain { 
        # Acquires an exclusive lock (only one owner)
        AcquireLock(LOCK_VM_Name, 1, 
        # Called once as the lock is acquired
        {
            VMInit(Name)
            # Invoke user code
            OnCreated
        },
        # Called as long as we have the lock
        {
            # Load the instruction associated with the byte at Name.Code[PC]
            ARRAYCpyTo(Name.Code, Name*PC, currentInstruction)
            # Execute the instruction
            Switch(currentInstruction, 
                { 
                    # The Halt instruction is a built-in that freezes the program counter in place
                    WORDDec(Name*PC) 
                    # The user may handle this halt event and reset the program counter to another value
                    Chain { OnHalt }
                },
                # All other instructions are for the user to provide
                Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, Op9, OpA, OpB, OpC, OpD, OpE, OpF
            )
            # Increase the program counter to move to the next instruction
            WORDInc(Name*PC)
            # Invoke user code
            OnTick
        })
    }
    destroyedEffect = Chain {
        VMInit(Name)
        ReleaseLock(LOCK_VM_Name)
        OnDestroyed
    }
}
End