Def Summon(Name)
	SummonEnemy "KEEPERTD_Name" {1} none
End

MakeGeneralPurposeVirtualMachine(Nexus, { "altar" },
# OnCreated
{
	# This is the program array. Each line corresponds to an address and an instruction.
	WORD(Nexus.Code[0] , 1)	# UI explaining the rules of the game and giving the player a chance to relocate before the Nexus placement is finalized
	WORD(Nexus.Code[1] , 2) # Timer that waits until the previous wave's cooldown has expired
	WORD(Nexus.Code[2] , 3) # Method that increases the wave counter and calculates the amount and monster types of the next wave
	WORD(Nexus.Code[3] , 4) # Method that spawns monsters over time as long as the wave is progressing
	WORD(Nexus.Code[4] , 5) # Method that waits for the player to complete the current wave by killing all monsters (see their deathEffect)
	WORD(Nexus.Code[5] , 6) # Method that rewards the player for completing the wave by dropping resources near the nexus
	WORD(Nexus.Code[6] , 7) # Finish rewarding the player then set the wave cooldown, unless it's wave 100 then jump to address 1
	WORD(Nexus.Code[7] , 8) # You won!!
	WORD(Nexus.Code[8] , 9) # Unused
	WORD(Nexus.Code[9] , A) # Unused
	WORD(Nexus.Code[10], B) # Unused
	WORD(Nexus.Code[11], C) # Unused
	WORD(Nexus.Code[12], D) # Unused
	WORD(Nexus.Code[13], E) # Unused
	WORD(Nexus.Code[14], F) # Unused
	WORD(Nexus.Code[15], 0)	# Halt, also used as a fatal exception handler here
	# The current wave goes from 1 to 100.
	DWORD(Nexus.CurrentWave, 0, 0)
	# Day = 1500 ticks; Night = 1500 ticks
	# The cooldown starts off at 40500 and goes down by 375 after each wave, to a minimum of 3000 on wave 100.
	QWORD(Nexus.WaveCooldown, 9, E, 3, 4)	
	# The theme of the current wave. There's 16 themes.
	WORD(Nexus.WaveTheme, 0)
	# The amount of enemies that are still alive during the current wave. Max 255 enemies per wave.
	DWORD(Nexus.EnemiesLeft, 0, 0)
	# Private variable that tracks the wave cooldown separately so its max value can be updated independently
	QWORD(Nexus._waveCooldown, 0, 0, 0, 0)
	# Private variables that track the current boss waves since calculating them would be more expensive
	WORD(Nexus._bossCounter, 0)
	WORD(Nexus._bossWavesCleared, 0)
	# Private variable that tracks the number of enemies that remain to spawn in the current wave
	DWORD(Nexus._enemiesToSpawn, 0, 0)
	# Modifier that scales the rewards at the end of a wave
	DWORD(Nexus._rewardModifier, 0, 0)
	DWORD(_tmp, 0, 1)

	# TODO: Remove this when the intro UI is implemented
	VMJumpConst(Nexus, 1)
},
# OnTick
{
	# KeeperTD: A tower defense mod for KeeperRL by G3Kappa.
	# Goal: defend this Nexus and your keeper from increasingly powerful monster waves.
	DWORDDebugPrint(Nexus._enemiesToSpawn)
	DWORDDebugPrint(Nexus.EnemiesLeft)
},
# OnHalt
{
},
# OnDestroyed
{
	if(Flag "Nexus.Victory") {

	}
	else(){
		# GAME OVER!
	}
	fi()
},
Op1(), Op2(), Op3(), Op4(), Op5(), Op6(), Op7(), Op8(), Op9(), OpA(), OpB(), OpC(), OpD(), OpE(), OpF()
)
# These are all the OpCodes for the virtual machine. The "Halt" OpCode (0) is built-in and triggers OnHalt.
Def Op1() Message NORMAL "Welcome to KeeperTD!"
End
Def Op2() Message NORMAL "Waiting for the the next wave..."
	# Sleep until the wave cooldown is equal to 0
	Filter Not DWORDEqConst(Nexus._waveCooldown, 0, 0) Chain {
		DWORDDec(Nexus._waveCooldown)
		WORDDec(Nexus*PC)
	}
End
Def Op3() Message NORMAL "Launching the next wave!"
	# Increase the wave number
	DWORDInc(Nexus.CurrentWave)
	WORDInc(Nexus._bossCounter)
	# If this is a boss wave, set the boss theme, otherwise randomize one
	if(WORDEqConst(Nexus._bossCounter, A)) {
		WORD(Nexus._bossCounter, 0)
		WORD(Nexus.WaveTheme, 0)
		SetFlag "Nexus.IsBossWave" true
	}
	else() {
		SetFlag "Nexus.IsBossWave" false
		WORDRandom(Nexus.WaveTheme)
		# Don't choose the boss theme
		Filter WORDEqConst(Nexus.WaveTheme, 0) Chain {
			WORD(Nexus.WaveTheme, 1) 
		}
	}
	fi()
	# Calculate the amount of monsters to send out during this wave as CurrentWave * 2.5 = CurrentWave * 2 + CurrentWave / 2
	DWORDCpy(Nexus.CurrentWave, Nexus.EnemiesLeft)
	DWORDCpy(Nexus.CurrentWave, _tmp)
	DWORDLShift(Nexus.EnemiesLeft, {})
	DWORDRShift(_tmp, {})
	DWORDAdd(Nexus.EnemiesLeft, _tmp)
	# Store a copy of this number in a temporary variable so that the next instruction can decrease it separately
	DWORDCpy(Nexus.EnemiesLeft, Nexus._enemiesToSpawn)
	# Use the wave number as the reward modifier
	DWORDCpy(Nexus.CurrentWave, Nexus._rewardModifier)
End
Def Op4() Message NORMAL "The wave is progressing..." 
	# Wait 50 ticks before spawning each monster
	Filter Not DWORDEqConst(Nexus._enemiesToSpawn, 0, 0) Chain {
		VMSleepConst(Nexus, 3, 2, {
			DWORDDec(Nexus._enemiesToSpawn)
			Switch(Nexus.WaveTheme, 
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) },
				ChooseRandom { Summon(Horse) }
			)
			WORDDec(Nexus*PC)
		})
	}
End
Def Op5() Message NORMAL "Waiting for the player to complete the wave..."
	Filter Not DWORDEqConst(Nexus.EnemiesLeft, 0, 0) Chain {
		WORDDec(Nexus*PC)
	}
End
Def Op6() Message NORMAL "Wave completed! Generating gold rewards..."
	# Gold reward = wave * rand(25,50)
	Filter Not DWORDEqConst(Nexus._rewardModifier, 0, 0) Chain {
		DWORDDec(Nexus._rewardModifier)
		DropItems { Simple "GoldPiece" } { 25 50 }
	}
End
Def Op7() Message NORMAL "Wave completed! Generating item rewards..."
	# Item reward: 50% chance to happen per wave, doesn't scale with wave
	Chance 0.50 Chain {
		# Choose from a random pool of random pools
		ChooseRandom {
			# Drop some pieces from a random armor set
			ChooseRandom {
				Chain {
					Chance 0.80 DropItems { Simple "LeatherHelm"   } { 1 5 }
					Chance 0.80 DropItems { Simple "LeatherArmor"  } { 1 5 }
					Chance 0.80 DropItems { Simple "LeatherGloves" } { 1 5 }
					Chance 0.80 DropItems { Simple "LeatherBoots"  } { 1 5 }
					Chance 0.80 DropItems { Simple "WoodenShield"  } { 1 5 }
				}
				Chain {
					Chance 0.60 DropItems { Simple "IronHelm"   } { 1 3 }
					Chance 0.60 DropItems { Simple "ChainArmor"  } { 1 3 }
					Chance 0.60 DropItems { Simple "IronGloves" } { 1 3 }
					Chance 0.60 DropItems { Simple "IronBoots"  } { 1 3 }
					Chance 0.60 DropItems { Simple "IronShield" } { 1 3 }
				}
				Chain {
					Chance 0.40 DropItems { Simple "AdaHelm"   } { 1 2 }
					Chance 0.40 DropItems { Simple "AdaArmor"  } { 1 2 }
					Chance 0.40 DropItems { Simple "AdaGloves" } { 1 2 }
					Chance 0.40 DropItems { Simple "AdaBoots"  } { 1 2 }
					Chance 0.40 DropItems { Simple "AdaShield" } { 1 2 }
				}
				Chain {
					Chance 0.20 DropItems { Simple "AdoxiumHelm"   } { 1 }
					Chance 0.20 DropItems { Simple "AdoxiumArmor"  } { 1 }
					Chance 0.20 DropItems { Simple "AdoxiumGloves" } { 1 }
					Chance 0.20 DropItems { Simple "AdoxiumBoots"  } { 1 }
				}
			}
			# Drop some assorted weapons
			Repeat(3, Chain {
				ChooseRandom {
					FirstSuccessful {
						Chance 0.10 DropItems { Simple "ArchwoodBow" } { 1 }
						Chance 0.30 DropItems { Simple "Crossbow" } { 1 }
						Chance 0.50 DropItems { Simple "ElvenBow" } { 1 2 }
						DropItems { Simple "Bow" } { 1 3 }
					}
					FirstSuccessful {
						Chance 0.10 DropItems { Simple "InferniteWarHammer" } { 1 }
						Chance 0.30 DropItems { Simple "AdaWarHammer" } { 1 2 }
						DropItems { Simple "WarHammer" } { 1 3 }
					}
					FirstSuccessful {
						Chance 0.10 DropItems { Simple "InferniteBattleAxe" } { 1 }
						Chance 0.30 DropItems { Simple "AdaBattleAxe" } { 1 2 }
						DropItems { Simple "BattleAxe" } { 1 3 }
					}
					FirstSuccessful {
						Chance 0.10 DropItems { Simple "InferniteSword" } { 1 }
						Chance 0.20 DropItems { Simple "AdaSword" } { 1 2 }
						Chance 0.40 DropItems { Simple "ElvenSword" } { 1 3 }
						Chance 0.60 DropItems { Simple "Sword" } { 1 4 }
						Chance 0.80 DropItems { Simple "Spear" } { 1 5 }
						DropItems { Simple "Knife" } { 1 10 }
					}
				}
			})
			# Drop some miscellaneous themed consumables
			ChooseRandom {
				Chain {
					Chance 0.20 DropItems { Potion Heal {FLESH}  } { 5 10 }
					Chance 0.20 DropItems { Potion Heal {SPIRIT} } { 5 10 }
					ChooseRandom {
						DropItems { Potion Heal {FLESH}  } { 3 6 }
						DropItems { Potion Heal {SPIRIT} } { 3 6 }
					}
				}
				ChooseRandom {
					DropItems { Potion Lasting SLEEP     } { 2 8 }
					DropItems { Potion Lasting SLOWED    } { 2 8 }
					DropItems { Potion Lasting BLIND     } { 2 8 }
					DropItems { Potion Lasting POISON    } { 2 8 }
					DropItems { Potion Lasting INSANITY  } { 2 8 }
					DropItems { Potion Lasting INVISIBLE } { 2 8 }
				}
			}
		}
	}
	# If this was a boss wave, spawn the appropriate victory reward, scales with boss wave
	Filter Flag "Nexus.IsBossWave" Chain {
		WORDInc(Nexus._bossWavesCleared)
		Switch(Nexus._bossWavesCleared,
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" },
			ChooseRandom { Message HIGH "Good job but I have to implement a reward for beating this wave" }
		)
	}
	# Update the wave cooldown by subtracting 375 to it unless it's <= 3000
	Filter Not QWORDEqConst(Nexus.WaveCooldown, 0, B, B, 8) Chain {
		QWORD(_tmp, 0, 1, 7, 7)
		QWORDSub(Nexus.WaveCooldown, _tmp)
		QWORDCpy(Nexus.WaveCooldown, Nexus._waveCooldown)
	}
	# If this ISN'T the last wave, jump back to the start of the program
	Filter Not DWORDEqConst(Nexus.CurrentWave, 6, 4) Chain {
		VMJumpConst(Nexus, 1)
	}
End
Def Op8() Message NORMAL "You won!"
	# Trigger the victory condition and cause a game over
	SetFlag "Nexus.Victory" true
	VMDestroy()
End
Def Op9() Message NORMAL "Instruction 9"
End
Def OpA() Message NORMAL "Instruction A"
End
Def OpB() Message NORMAL "Instruction B"
End
Def OpC() Message NORMAL "Instruction C"
End
Def OpD() Message NORMAL "Instruction D"
End
Def OpE() Message NORMAL "Instruction E"
End
Def OpF()
	DWORDRShift(_tmp)
	DWORDDebugPrint(_tmp)
	WORDDec(Nexus*PC)
End
